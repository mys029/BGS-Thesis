---
title: "Thesis"
author: "Dylan Li"
format: 
  html:
    theme: 
      light: flatly
    page-layout: article
    code-fold: true
    self-contained: true
    code-tools: true
    toc: true
execute:
  echo: true
  error: true
  message: false
  warning: false
embed-resources: true
editor: visual
---

## Libraries

```{r}
#| label: libraries

library(tidyverse)
library(tidymodels)
library(glmnet)
library(discrim)
library(rpart)
library(rpart.plot)
library(baguette)
library(tidyclust)
library(caret)
```

## Testing different scoring methods

### Grid Setup

```{r}
#| label: grids

sample_grid <- matrix(c("Bear", "Bee", "Meadow", "Bear", "Meadow", "Meadow", "Bee", "Meadow", "Bee"),3,3,byrow=TRUE)
sample_grid

sample_grid2 <- matrix(c("Meadow", "Meadow", "Bee", "Meadow", "Bee", "Meadow", "Bee", "Meadow", "Meadow"),3,3,byrow=TRUE)
sample_grid2

big_grid1 <- matrix(c("Deer", "Meadow", "Bee", "Bear", "Fox", "Wolf", "Meadow", "Meadow", "Trout", "Stream",
                      "Deer", "Eagle", "Meadow", "Trout", "Stream", "Fox", "Rabbit", "Stream", "Dragonfly",
                      "Stream"),4,5,byrow=TRUE)
big_grid1

twenty_seven_x <- rep("x", 27)

super_vec <- append(twenty_seven_x, 
                      c("x", "x", 
                        "Deer", "Meadow", "Bee", "Bear", "Fox", 
                        "x", "x", 
                        "x", "x", 
                        "Wolf", "Meadow", "Meadow", "Trout", "Stream",
                        "x", "x", 
                        "x", "x", 
                        "Deer", "Eagle", "Meadow", "Trout", "Stream", 
                        "x", "x", 
                        "x", "x", 
                        "Fox", "Rabbit", "Stream", "Dragonfly","Stream",
                        "x", "x"))

super_grid1 <- matrix(super_vec,7,9,byrow=TRUE)
super_grid1
```

### Board Generation

```{r}
cards <- c(rep("Bear", 12), 
           rep("Bee", 8), 
           rep("Meadow", 20),
           rep("Trout", 10),
           rep("Eagle", 8),
           rep("Rabbit", 8),
           rep("Dragonfly", 8),
           rep("Fox", 12),
           rep("Deer", 12),
           rep("Stream", 20),
           rep("Wolf", 12)
           )

generate_grid <- function(pool, partial_grid = NULL){
  if(is.null(partial_grid) == FALSE){
    blanks <- which(partial_grid == "x", TRUE)
    n = 20 - nrow(blanks)
    
  }else{
    n = 20
  }
  
  sample <- sample(pool, n)
  
  if(is.null(partial_grid) == FALSE){
    
    board <- partial_grid
    
    for (i in 1:nrow(blanks)){
      loc <- c(blanks[[i, 1]], blanks[[i, 2]])
      board[blanks[[i, 1]], blanks[[i, 2]]] = sample[i]
    }
    
  }else{
    board <- matrix(sample, nrow=4, ncol=5, byrow=TRUE)
  }
  
  return(board)
}

generate_grid(cards)
```

### Helper functions

```{r}
find_cardinals <- function(i, j, grid){
  cardinals <- list()
  maxrow = nrow(grid)
  maxcol = ncol(grid)
      
  if(i+1 <= maxrow){
    cardinals[[length(cardinals)+1]] <- c(i+1,j)
  }
  
  if(i-1 > 0){
    cardinals[[length(cardinals)+1]] <- c(i-1,j)
  }
  
  if(j+1 <= maxcol){
    cardinals[[length(cardinals)+1]] <- c(i,j+1)
  }
  
  if(j-1 > 0){
    cardinals[[length(cardinals)+1]] <- c(i,j-1)
  }
  
  return(cardinals)
}
```

```{r}
find_two_spaces <- function(i, j, grid){
  two_space <- list()
  maxrow = nrow(grid)
  maxcol = ncol(grid)
      
  if(i+1 <= maxrow){
    two_space[[length(two_space)+1]] <- c(i+1,j)
  }
  
  if(i+2 <= maxrow){
    two_space[[length(two_space)+1]] <- c(i+2,j)
  }
  
  if(i-1 > 0){
    two_space[[length(two_space)+1]] <- c(i-1,j)
  }
  
  if(i-2 > 0){
    two_space[[length(two_space)+1]] <- c(i-2,j)
  }
  
  if(j+1 <= maxcol){
    two_space[[length(two_space)+1]] <- c(i,j+1)
  }
  
  if(j+2 <= maxcol){
    two_space[[length(two_space)+1]] <- c(i,j+2)
  }
  
  if(j-1 > 0){
    two_space[[length(two_space)+1]] <- c(i,j-1)
  }
  
  if(j-2 > 0){
    two_space[[length(two_space)+1]] <- c(i,j-2)
  }
  
  if(i+1 <= maxrow && j+1 <= maxcol){
    two_space[[length(two_space)+1]] <- c(i+1,j+1)
  }
  
  if(i+1 <= maxrow && j-1 > 0){
    two_space[[length(two_space)+1]] <- c(i+1,j-1)
  }
  
  if(i-1 > 0 && j+1 <= maxcol){
    two_space[[length(two_space)+1]] <- c(i-1,j+1)
  }
  
  if(i-1 > 0 && j-1 > 0){
    two_space[[length(two_space)+1]] <- c(i-1,j-1)
  }
  
  return(two_space)
}
```

```{r}
find_more_meadows <- function(i, j, grid, meadow_list){
  meadow_list[[length(meadow_list)+1]] = as.double(c(i,j))
  current_caridnals <- find_cardinals(i, j, grid)
  for (k in current_caridnals){
    if (grid[k[1],k[2]] == "Meadow"){
      if ((list(k) %in% meadow_list) == FALSE){
        meadow_list = find_more_meadows(as.double(k[1]),as.double(k[2]), grid, meadow_list)
      }
    }
  }
  return(meadow_list)
  
}
```

```{r}
find_more_streams <- function(i, j, grid, stream_list){
  stream_list[[length(stream_list)+1]] = as.double(c(i,j))
  current_caridnals <- find_cardinals(i, j, grid)
  for (k in current_caridnals){
    if (grid[k[1],k[2]] == "Stream"){
      if ((list(k) %in% stream_list) == FALSE){
        stream_list = find_more_streams(as.double(k[1]),as.double(k[2]), grid, stream_list)
      }
    }
  }
  return(stream_list)
  
}
```

### Scoring function

```{r}
#| label: grid-scoring-function

score_grid <- function(grid){
  
  score = 0
  
  meadow_patch = list()
  first_meadow = TRUE
  stream_patch = list()
  first_stream = TRUE
  dragonfly_list = list()
  deer_row <- c()
  deer_col <- c()
  # first_wolf = TRUE
  num_wolves = 0
  
  
  bear_score = 0
  bee_score = 0
  meadow_score = 0
  trout_score = 0
  eagle_score = 0
  rabbit_score = 0
  dragonfly_score = 0
  fox_score = 0
  deer_score = 0
  stream_score = 0
  wolf_score = 0
  diversity_score = 0
  
  for (i in 1:nrow(grid)) {
    for (j in 1:ncol(grid)) {
      
      current_caridnals <- find_cardinals(i, j, grid)
      
      
      if(grid[i,j] == "Bear"){
        for (k in current_caridnals){
          if (grid[k[1],k[2]] == "Bee" || grid[k[1],k[2]] == "Trout"){
            score = score + 2
            bear_score = bear_score + 2
          }
        }
      }
      
      if(grid[i,j] == "Bee"){
        for (k in current_caridnals){
          if (grid[k[1],k[2]] == "Meadow"){
            score = score + 3
            bee_score = bee_score + 3
          }
        }
      }
      
      if(grid[i,j] == "Meadow"){
        if (first_meadow == TRUE){
          
          first_meadow = FALSE
          first_patch = list()
          completed_patch = find_more_meadows(as.double(i), as.double(j), grid, first_patch)
          meadow_patch[[length(meadow_patch)+1]] = completed_patch
          
        }else{
          
          exist = FALSE
          
          for (x in 1:length(meadow_patch)){
            if (list(as.double(c(i,j))) %in% meadow_patch[[x]]){
              exist = TRUE
            }
          }
          
          if (exist == FALSE){
            new_patch = list()
            completed_patch = find_more_meadows(as.double(i), as.double(j), grid, new_patch)
            meadow_patch[[length(meadow_patch)+1]] = completed_patch
          }
          
        }
      }
      
      if(grid[i,j] == "Trout"){
        for (k in current_caridnals){
          if (grid[k[1],k[2]] == "Dragonfly" || grid[k[1],k[2]] == "Stream"){
            score = score + 2
            trout_score = trout_score + 2
          }
        }
      }
      
      if(grid[i,j] == "Eagle"){
        
        two_space <- find_two_spaces(i, j, grid)
        
        for (k in two_space){
          if (grid[k[1],k[2]] == "Trout" || grid[k[1],k[2]] == "Rabbit"){
            score = score + 2
            eagle_score = eagle_score + 2
          }
        }
      }
      
      if(grid[i,j] == "Rabbit"){
        score = score + 1
        rabbit_score = rabbit_score + 1
      }
      
      if(grid[i,j] == "Dragonfly"){
        dragonfly_list[[length(dragonfly_list)+1]] = as.double(c(i,j))
      }
      
      if(grid[i,j] == "Fox"){
        score_it = TRUE
        
        for (k in current_caridnals){
          if (grid[k[1],k[2]] == "Bear" || grid[k[1],k[2]] == "Wolf"){
            score_it = FALSE
          }
        }
        
        if (score_it){
          score = score + 3
          fox_score = fox_score + 3
        }
      }
      
      if(grid[i,j] == "Deer"){
        deer_row <- append(deer_row, i)
        deer_col <- append(deer_col, j)
      }
      
      if(grid[i,j] == "Stream"){
        if (first_stream == TRUE){
          
          first_stream = FALSE
          first_patch = list()
          completed_patch = find_more_streams(as.double(i), as.double(j), grid, first_patch)
          stream_patch[[length(stream_patch)+1]] = completed_patch
          
        }else{
          
          exist = FALSE
          
          for (x in 1:length(stream_patch)){
            if (list(as.double(c(i,j))) %in% stream_patch[[x]]){
              exist = TRUE
            }
          }
          
          if (exist == FALSE){
            new_patch = list()
            completed_patch = find_more_streams(as.double(i), as.double(j), grid, new_patch)
            stream_patch[[length(stream_patch)+1]] = completed_patch
          }
          
        }
      }
      
      if(grid[i,j] == "Wolf"){
        # temporary stand in, can only be scored properly with more than 1 player
        # if (first_wolf == TRUE){
        #   score = score + 8
        #   wolf_score = wolf_score + 8
        #   first_wolf == FALSE
        # }
        
        num_wolves = num_wolves + 1
      }
      
    }
  }
  
  for (i in meadow_patch){
    if (length(i) == 2){
      score = score + 3
      meadow_score = meadow_score + 3
    }else if (length(i) == 3){
      score = score + 6
      meadow_score = meadow_score + 6
    }else if (length(i) == 4){
      score = score + 10
      meadow_score = meadow_score + 10
    }else if (length(i) >= 5){
      score = score + 15
      meadow_score = meadow_score + 15
    }
  }
  
  largest_stream = 0
  
  for (i in stream_patch){
    if (length(i) > largest_stream){
      largest_stream = length(i)
    }
  }
  
  # temporary scoring for largest stream, can only be scored properly with more than 1 player
  # if (largest_stream > 0){
  #   score = score + 5
  #   stream_score = stream_score + 5
  # }
  
  for (d in dragonfly_list){
    current_caridnals <- find_cardinals(d[1], d[2], grid)
    
    largest_score = 0
    
    for (k in current_caridnals){
      if (grid[k[1],k[2]] == "Stream"){
        for (s in stream_patch){
          if((list(k) %in% s) == TRUE){
            current_score = 2 * length(s)
            if (current_score > largest_score){
              largest_score = current_score
            }
          }
        }
      }
    }
    
    score = score + largest_score
    dragonfly_score = dragonfly_score + largest_score
  }
  
  score = score + 2*length(unique(deer_row))
  score = score + 2*length(unique(deer_col))
  
  deer_score = deer_score + 2*length(unique(deer_row))
  deer_score = deer_score + 2*length(unique(deer_col))
  
  diversity_matrix <- matrix(c(bear_score, bee_score, meadow_score, trout_score, eagle_score, rabbit_score,
           dragonfly_score, fox_score, deer_score))

  gaps = colSums(diversity_matrix == 0)[1]
   
  # if(gaps >= 6){
  #   score = score - 5
  #   diversity_score = -5
  # }else if (gaps == 4){
  #   score = score + 3
  #   diversity_score = 3
  # }else if (gaps == 3){
  #   score = score + 7
  #   diversity_score = 7
  # }else if (gaps <= 2){
  #   score = score + 12
  #   diversity_score = 12
  # }
  
  return(c(score, largest_stream, num_wolves, gaps))
}
```

### Solo play scoring

```{r}
solo_score <- function(score_vector){
  score = score_vector[1]
  stream_size = score_vector[2]
  num_wolves = score_vector[3]
  num_gaps = score_vector[4]
  
  score = score + stream_size + num_wolves
  
  if(stream_size == 0){
    num_gaps = num_gaps + 1
  }
  if(num_wolves == 0){
    num_gaps = num_gaps + 1
  }
  
  if(num_gaps >= 6){
      score = score - 5
    }else if (num_gaps == 4){
      score = score + 3
    }else if (num_gaps == 3){
      score = score + 7
    }else if (num_gaps <= 2){
      score = score + 12
    }
  
  return(score)
}
```

### Multiplayer Scoring

```{r}
mp_score <- function(score_list){
  
  # each entry in score_list follows the format: c(score, size_of_largest_stream, num_wolves, diversity_gaps)
  
  if(length(score_list) > 2){
    more_than_2 = TRUE
  }else{
    more_than_2 = FALSE
  }
  
  score <- rep(0, length(score_list))
  stream_size <- rep(0, length(score_list))
  num_wolves <- rep(0, length(score_list))
  num_gaps <- rep(0, length(score_list))
  
  for (i in 1:length(score_list)){
    
    score[i] = score_list[[i]][1]
    
    stream_size[i] = score_list[[i]][2]
    
    num_wolves[i] = score_list[[i]][3]
    
    num_gaps[i] = score_list[[i]][4] + 2
    
  }
  
  print(score)
  
  stream_size = sort(stream_size, decreasing = TRUE)
  num_wolves = sort(num_wolves, decreasing = TRUE)
  
  stream_matrix = matrix(stream_size)
  wolf_matrix = matrix(num_wolves)
  
  largest_stream = stream_size[1]
  second_stream = stream_size[2]
  
  score_largest_s = TRUE
  score_second_s = TRUE
  
  if(colSums(stream_matrix == largest_stream)[1] > 1){
    score_second_s = FALSE
  }
  
  for (i in 1:length(score_list)){
      if (score_list[[i]][2] == largest_stream && largest_stream != 0){
        score[i] = score[i] + 8
        num_gaps[i] = num_gaps[i] - 1
      }
  }
  
  if(score_second_s == TRUE){
    for (i in 1:length(score_list)){
      if (score_list[[i]][2] == second_stream && second_stream != 0){
        score[i] = score[i] + 5
        num_gaps[i] = num_gaps[i] - 1
      }
    }
  }
  
  print(score)
  
  most_wolves = num_wolves[1]
  second_wolves = num_wolves[2]
  if(more_than_2){
    third_wolves = num_wolves[3]
  }
  
  score_most_w = TRUE
  score_second_w = TRUE
  score_third_w = TRUE
  
  if(colSums(wolf_matrix == most_wolves)[1] > 1){
    score_second_w = FALSE
    if(colSums(wolf_matrix == most_wolves)[1] > 2){
      score_third_w = FALSE
    }
  }
  
  for (i in 1:length(score_list)){
      if (score_list[[i]][3] == most_wolves){
        score[i] = score[i] + 12
        num_gaps[i] = num_gaps[i] - 1
      }
  }
  
  if(colSums(wolf_matrix == second_wolves)[1] > 1){
    score_third_w = FALSE
  }
  
  if(score_second_w == TRUE){
    for (i in 1:length(score_list)){
      if (score_list[[i]][3] == second_wolves){
        score[i] = score[i] + 8
        num_gaps[i] = num_gaps[i] - 1
      }
    }
  }
  
  if(score_third_w == TRUE && more_than_2 == TRUE){
    for (i in 1:length(score_list)){
      if (score_list[[i]][3] == third_wolves){
        score[i] = score[i] + 4
        num_gaps[i] = num_gaps[i] - 1
      }
    }
  }
  
  print(score)
  
  for(i in 1:length(score_list)){
    if(num_gaps[i] >= 6){
      score[i] = score[i] - 5
    }else if (num_gaps[i] == 4){
      score[i] = score[i] + 3
    }else if (num_gaps[i] == 3){
      score[i] = score[i] + 7
    }else if (num_gaps[i] <= 2){
      score[i] = score[i] + 12
    }
  }
  
  
  
  return(score)
  
}
```

### Baseline function

```{r}
baseline_sim <- function(cards, n = 10000){
  all_scores <- c()
  for (i in 1:n){
    sim_grid <- generate_grid(cards)
    all_scores <- c(all_scores, solo_score(score_grid(sim_grid)))
  }
  return(all_scores)
}
```

### Random Walk MCMC

```{r}
rw_mcmc <- function(grid, iterations = 1000, acceptance_func = "simple", beta = 0, bp = 500, original = NULL, record_board = FALSE){
  start_score <- solo_score(score_grid(grid))
  current_grid <- grid
  continue <- TRUE
  rows <- rep(1:nrow(grid))
  cols <- rep(1:ncol(grid))
  iter = 0
  score_vector <- c()
  highest_score <- start_score
  highest_grid <- grid
  highest_iter <- 0
  
  while(continue){
    current_score <- solo_score(score_grid(current_grid))
    if(bp == 0){
    }else if(iter%%bp == 0){
      if(acceptance_func == "annealing dynamic" || 
         acceptance_func == "delayed"){
        current_grid = highest_grid
        current_score = highest_score
      }
    }
    score_vector = c(score_vector, current_score)
    if(current_score > highest_score){
      highest_score = current_score
      highest_grid = current_grid
      highest_iter = iter
    }
    
    # Choosing swap locations if grid is partially complete
    if(is.null(original) == FALSE){
      blanks <- which(original == "x", TRUE)
      possible <- list()
      
      for (i in 1:nrow(blanks)){
        loc <- c(blanks[[i, 1]], blanks[[i, 2]])
        possible[[length(possible)+1]] = loc
      }
      
      start_loc <- sample(possible, 1)
      start_loc <- start_loc[[1]]
      start_row <- start_loc[1]
      start_col <- start_loc[2]
      
      end_loc <- sample(possible, 1)
      end_loc <- end_loc[[1]]
      end_row <- end_loc[1]
      end_col <- end_loc[2]
      
      while(current_grid[start_row, start_col] == current_grid[end_row, end_col]){
        end_loc <- sample(possible, 1)
        end_loc <- end_loc[[1]]
        end_row <- end_loc[1]
        end_col <- end_loc[2]
      }
    
    # Choosing swap locations without partial grid  
    }else{
      
      start_row <- sample(rows, 1)
      start_col <- sample(cols, 1)
      
      # Random swap anywhere
      end_row <- sample(rows, 1)
      end_col <- sample(cols, 1)
  
      while(current_grid[start_row, start_col] == current_grid[end_row, end_col]){
        end_row <- sample(rows, 1)
        end_col <- sample(cols, 1)
      }
    }
    # Adjacent swap only
    # possible_end <- find_cardinals(start_row, start_col, grid)
    # end <- sample(possible_end, 1)
    # end_row <- end[[1]][1]
    # end_col <- end[[1]][2]
    
    proposed_grid <- current_grid
    
    # if(iter == 347 || iter == 668){
    #   print(proposed_grid)
    # }
    
    start <- current_grid[start_row, start_col]
    end <- current_grid[end_row, end_col]
    
    proposed_grid[start_row, start_col] = end
    proposed_grid[end_row, end_col] = start
    
    proposed_score <- solo_score(score_grid(proposed_grid))
    
    if(acceptance_func == "simple"){
      p = proposed_score
      c = current_score
      if(p <= 0){
        p = p + -1*p + 1
        c = c + -1*p + 1
      }
      if(c <= 0){
        c = c + -1*c + 1
        p = p + -1*c + 1
      }
      
      x <- runif(1,0,1)
      if(x < p/c){
        current_grid <- proposed_grid
      }
    }
    
    if(acceptance_func == "annealing"){
      p = proposed_score
      c = current_score
      
      x <- runif(1,0,1)
      if(x < exp(beta*p)/exp(beta*c)){
        current_grid <- proposed_grid
      }
    }
    
    if(acceptance_func == "annealing dynamic"){
      p = proposed_score
      c = current_score
      
      factor = floor(iter/bp) + 1
      b = beta*(factor)
      
      x <- runif(1,0,1)
      if(x < exp(b*p)/exp(b*c)){
        current_grid <- proposed_grid
      }
    }
    
    if(acceptance_func == "delayed"){
      p = proposed_score
      c = current_score
      if(p <= 0){
        p = p + -1*p + 1
        c = c + -1*p + 1
      }
      if(c <= 0){
        c = c + -1*c + 1
        p = p + -1*c + 1
      }
      
      x <- runif(1,0,1)
      if(x < p/c && p/c < 1){
        p2 = proposed_score
        c2 = current_score
        
        factor = floor(iter/500) + 1
        b = beta*(factor)
        
        x <- runif(1,0,1)
        if(x < (exp(b*p2)*c)/(exp(b*c2)*p)){
          current_grid <- proposed_grid
        }
      }else if(p/c >= 1){
        current_grid <- proposed_grid
      }
    }
    
    iter = iter + 1
      if(iter >= iterations){
        continue = FALSE
      }
  }
  
  final_score <- solo_score(score_grid(current_grid))
  if(final_score > highest_score){
      highest_score = final_score
      highest_grid = grid
    }
  
  if(record_board == TRUE){
    return(c(t(highest_grid), highest_score))
  }else{
    return(c(highest_score, final_score, start_score, highest_iter, data.frame(score_vector)))
  }
}
```

```{r}
multi_mcmc <- function(iterations, n, acceptance_func = "simple", beta = 0, bp = 500, grid = NULL, boardlist = NULL, record_board = FALSE, cards = NULL, card_name = NULL){
  first = TRUE
  start_scores <- c()
  highest_scores <- c()
  highest_iter <- c()
  if(is.null(cards) == TRUE){
    cards <- c(rep("Bear", 12), 
           rep("Bee", 8), 
           rep("Meadow", 20),
           rep("Trout", 10),
           rep("Eagle", 8),
           rep("Rabbit", 8),
           rep("Dragonfly", 8),
           rep("Fox", 12),
           rep("Deer", 12),
           rep("Stream", 20),
           rep("Wolf", 12)
           )
    card_name = "default"
  }
  
  
  # Creating proper pool of cards if grid is partially complete
  if(is.null(grid) == FALSE){
    df <- as.data.frame(table(grid))
    animals <- levels(df$grid)
    for(i in 1:nrow(grid)){
      animal <- animals[i]
      num = length(cards[cards == animal])
      cards = cards[!cards == animal]
      cards <- c(cards, rep(animal, num - df[i,2]))
    }
  }
  
  for(i in 1:n){
    
    if(is.null(grid) == FALSE){
      
      if(record_board == TRUE){
        sim_grid <- generate_grid(cards, grid)
        run <- rw_mcmc(sim_grid, iterations, acceptance_func, beta, bp, grid, record_board = TRUE)
      }else{
        sim_grid <- generate_grid(cards, grid)
        run <- rw_mcmc(sim_grid, iterations, acceptance_func, beta, bp, grid)
      }
      
    }else if(is.null(boardlist) == FALSE){
      
      if(record_board == TRUE){
        run <- rw_mcmc(boardlist[[i]], iterations, acceptance_func, beta, bp, record_board = TRUE)
      }else{
        run <- rw_mcmc(boardlist[[i]], iterations, acceptance_func, beta, bp)
      }
      
    }else{
      if(record_board == TRUE){
        sim_grid <- generate_grid(cards)
        run <- rw_mcmc(sim_grid, iterations, acceptance_func, beta, bp, record_board = TRUE)
      }else{
        sim_grid <- generate_grid(cards)
        run <- rw_mcmc(sim_grid, iterations, acceptance_func, beta, bp)
      }
    }
    
    if(record_board == TRUE){
      if(first == TRUE){
        first = FALSE
        
        df <- data.frame(
          row1col1 = run[[1]],
          row1col2 = run[[2]],
          row1col3 = run[[3]],
          row1col4 = run[[4]],
          row1col5 = run[[5]],
          row2col1 = run[[6]],
          row2col2 = run[[7]],
          row2col3 = run[[8]],
          row2col4 = run[[9]],
          row2col5 = run[[10]],
          row3col1 = run[[11]],
          row3col2 = run[[12]],
          row3col3 = run[[13]],
          row3col4 = run[[14]],
          row3col5 = run[[15]],
          row4col1 = run[[16]],
          row4col2 = run[[17]],
          row4col3 = run[[18]],
          row4col4 = run[[19]],
          row4col5 = run[[20]],
          score = run[[21]],
          pool = card_name
        )
        
      }else{
        row <- data.frame(
          row1col1 = run[[1]],
          row1col2 = run[[2]],
          row1col3 = run[[3]],
          row1col4 = run[[4]],
          row1col5 = run[[5]],
          row2col1 = run[[6]],
          row2col2 = run[[7]],
          row2col3 = run[[8]],
          row2col4 = run[[9]],
          row2col5 = run[[10]],
          row3col1 = run[[11]],
          row3col2 = run[[12]],
          row3col3 = run[[13]],
          row3col4 = run[[14]],
          row3col5 = run[[15]],
          row4col1 = run[[16]],
          row4col2 = run[[17]],
          row4col3 = run[[18]],
          row4col4 = run[[19]],
          row4col5 = run[[20]],
          score = run[[21]],
          pool = card_name
        )
        df <- rbind(df, row) 
      }
    }else{
      start_scores <- c(start_scores, run[[3]])
      highest_scores <- c(highest_scores, run[[1]])
      highest_iter <- c(highest_iter, run[[4]])
    }
    
  }
  
  if(record_board == TRUE){
    return(df)
  }else{
    return(list(start_scores, highest_scores, highest_iter))
  }
  
}
```

```{r, eval=FALSE}
set.seed(4)
x1 <- multi_mcmc(2000, 100, "simple")
```

```{r, eval=FALSE}
mean(x1[[1]])
sd(x1[[1]])
var(x1[[1]])
max(x1[[1]])
min(x1[[1]])
summary(x1[[1]])
```

```{r, eval=FALSE}
mean(x1[[2]])
sd(x1[[2]])
var(x1[[2]])
max(x1[[2]])
min(x1[[2]])
summary(x1[[2]])
summary(x1[[3]])
```

```{r, eval=FALSE}
set.seed(4)
x2 <- multi_mcmc(2000, 100, "annealing", 0.8, 250)
```

```{r, eval=FALSE}
mean(x2[[1]])
sd(x2[[1]])
var(x2[[1]])
max(x2[[1]])
min(x2[[1]])
summary(x2[[1]])
```

```{r, eval=FALSE}
mean(x2[[2]])
sd(x2[[2]])
var(x2[[2]])
max(x2[[2]])
min(x2[[2]])
summary(x2[[2]])
summary(x2[[3]])
```

```{r, eval=FALSE}
set.seed(4)
x3 <- multi_mcmc(2000, 100, "annealing dynamic", 0.08, 250)
```

```{r, eval=FALSE}
mean(x3[[1]])
sd(x3[[1]])
var(x3[[1]])
max(x3[[1]])
min(x3[[1]])
summary(x3[[1]])
```

```{r, eval=FALSE}
mean(x3[[2]])
sd(x3[[2]])
var(x3[[2]])
max(x3[[2]])
min(x3[[2]])
summary(x3[[2]])
summary(x3[[3]])
```

```{r, eval=FALSE}
set.seed(4)
x4 <- multi_mcmc(2000, 100, "annealing dynamic", 0.2, 250)
```

```{r, eval=FALSE}
mean(x4[[1]])
sd(x4[[1]])
var(x4[[1]])
max(x4[[1]])
min(x4[[1]])
summary(x4[[1]])
```

```{r, eval=FALSE}
mean(x4[[2]])
sd(x4[[2]])
var(x4[[2]])
max(x4[[2]])
min(x4[[2]])
summary(x4[[2]])
```

```{r, eval=FALSE}
set.seed(49)
x5 <- multi_mcmc(2000, 100, "annealing", 0.8, 250)
```

```{r, eval=FALSE}
mean(x5[[1]])
sd(x5[[1]])
var(x5[[1]])
max(x5[[1]])
min(x5[[1]])
summary(x5[[1]])
```

```{r, eval=FALSE}
mean(x5[[2]])
sd(x5[[2]])
var(x5[[2]])
max(x5[[2]])
min(x5[[2]])
summary(x5[[2]])
summary(x5[[3]])
```

```{r, eval=FALSE}
set.seed(49)
x6 <- multi_mcmc(2000, 100, "delayed", 0.2, 250)
```

```{r, eval=FALSE}
mean(x6[[1]])
sd(x6[[1]])
var(x6[[1]])
max(x6[[1]])
min(x6[[1]])
summary(x6[[1]])
```

```{r, eval=FALSE}
mean(x6[[2]])
sd(x6[[2]])
var(x6[[2]])
max(x6[[2]])
min(x6[[2]])
summary(x6[[2]])
summary(x6[[3]])
```

```{r, eval=FALSE}
set.seed(49)
x7 <- multi_mcmc(1000, 1000, "annealing", 0.8, 250)
```

```{r, eval=FALSE}
mean(x7[[1]])
sd(x7[[1]])
var(x7[[1]])
max(x7[[1]])
min(x7[[1]])
summary(x7[[1]])
```

```{r, eval=FALSE}
mean(x7[[2]])
sd(x7[[2]])
var(x7[[2]])
max(x7[[2]])
min(x7[[2]])
summary(x7[[2]])
summary(x7[[3]])
```

```{r}
test_grid1 <- matrix(c("x", "Bee", "Meadow", "x", "x", "x", "Meadow", "Meadow", "x", "x",
                      "Deer", "Bee", "Meadow", "x", "x", "x", "Bear", "Bee", "Deer",
                      "x"),4,5,byrow=TRUE)
test_grid1
```
```{r, eval=FALSE}
set.seed(4)
partial1 <- multi_mcmc(1000, 100, "annealing", 0.8, 200, test_grid1)
```

```{r, eval=FALSE}
mean(partial1[[1]])
sd(partial1[[1]])
var(partial1[[1]])
max(partial1[[1]])
min(partial1[[1]])
summary(partial1[[1]])
```

```{r, eval=FALSE}
mean(partial1[[2]])
sd(partial1[[2]])
var(partial1[[2]])
max(partial1[[2]])
min(partial1[[2]])
summary(partial1[[2]])
summary(partial1[[3]])
```


### Tuning

```{r}
tune <- function(iter, beta, bp, type, boardlist = NULL){
  beta_df <- c()
  bp_df <- c()
  iter_df <- c()
  start_score <- c()
  highest_score <- c()
  iter_at_highest <- c()
  highest_score_sd <- c()
  highest_iter_sd <- c()
  max_highest <- c()
  percentile_90 <- c()
  score_75_plus <- c()
  for(i in beta){
    for (j in bp){
      for(k in iter){
        if(is.null(boardlist) == FALSE){
          sim <- multi_mcmc(k, 100, type, i, j, boardlist = boardlist)
        }else{
          sim <- multi_mcmc(k, 100, type, i, j)
        }
        beta_df <- c(beta_df, i)
        bp_df <- c(bp_df, j)
        iter_df <- c(iter_df, k)
        start_score <- c(start_score, mean(sim[[1]]))
        highest_score <- c(highest_score, mean(sim[[2]]))
        iter_at_highest <- c(iter_at_highest, mean(sim[[3]]))
        highest_iter_sd <- c(highest_iter_sd, sd(sim[[3]]))
        highest_score_sd <- c(highest_score_sd, sd(sim[[2]]))
        max_highest <- c(max_highest, max(sim[[2]]))
        percentile_90 <- c(percentile_90, quantile(sim[[2]],probs=0.9))
        s <- sim[[2]]
        score_75_plus <- c(score_75_plus, length(s[s>=75]))
      }
      
    }
  }
  
  df <- data.frame(
    iterations = iter_df,
    beta = beta_df,
    break_point = bp_df,
    mean_start_score = start_score,
    mean_highest_score = highest_score,
    sd_highest_score = highest_score_sd,
    max_score = max_highest,
    score_90th_percent = percentile_90,
    score_75_plus = score_75_plus,
    average_iterations = iter_at_highest,
    sd_iterations = highest_iter_sd,
    type = type
  )
  
  return(df)
}
```

```{r, eval=FALSE}
beta <- c(0.3,0.8,0.9)
bp <- c(125, 250)
iter <- c(500, 750)

set.seed(4)
tune1 <- tune(iter, beta, bp, "delayed")
```

```{r, eval=FALSE}
tune1
```

```{r}
generate_100 <- function(pool){
  board_list <- list()
  for(i in 1:100){
    board <- generate_grid(pool)
    board_list[[length(board_list)+1]] = board
  }
  return(board_list)
}
```

```{r, eval=FALSE}
# set.seed(88)
set.seed(89)
board100 <- generate_100(cards)
```

```{r, eval=FALSE}
tune_exact1 <- tune(1000, 0.99, 250, "annealing dynamic", boardlist = board100)
tune_exact2 <- tune(1000, 0.9, 200, "annealing dynamic", boardlist = board100)
tune_exact3 <- tune(2000, 0.7, 500, "delayed", boardlist = board100)
tune_exact4 <- tune(2000, 0.8, 500, "annealing dynamic", boardlist = board100)
tune_exact5 <- tune(1500, 0.9, 500, "annealing dynamic", boardlist = board100)
tune_exact6 <- tune(750, 0.99, 250, "annealing dynamic", boardlist = board100)
tune_exact7 <- tune(750, 0.3, 250, "delayed", boardlist = board100)
tune_exact8 <- tune(500, 0.99, 250, "annealing dynamic", boardlist = board100)
tune_exact9 <- tune(2000, 0.9, 250, "annealing dynamic", boardlist = board100)
tune_exact10 <- tune(750, 0.9, 125, "annealing dynamic", boardlist = board100)
tune_exact11 <- tune(1500, 0.9, 250, "annealing dynamic", boardlist = board100)
```

```{r}
final_params <- rbind(tune_exact1,
                      tune_exact2,
                      tune_exact3,
                      tune_exact4,
                      tune_exact5,
                      tune_exact6,
                      tune_exact7,
                      tune_exact8,
                      tune_exact9,
                      tune_exact10,
                      tune_exact11)

write.csv(final_params,here::here("final-parameters-seed2.csv"), row.names = FALSE)
```

```{r, eval=FALSE}
# write.csv(tune1,here::here("new-parameters.csv"),row.names = FALSE)
```

```{r, eval=FALSE}
tuned_params1 <- read.csv(here::here("final-parameters.csv"))
```

```{r, eval=FALSE}
new_params <- rbind(tuned_params1, tune1)
write.csv(new_params,here::here("new-parameters.csv"), row.names = FALSE)
```


```{r}
set.seed(45)
sim_grid1 <- generate_grid(cards)
x <- rw_mcmc(sim_grid1, 2000, "annealing dynamic", beta = 0.8, 250)
```

```{r}
xz <- data.frame(iter = rep(1:length(x[[4]])), scores = x[[4]])
ggplot(aes(x = iter, y = scores), data = xz) +
  geom_line()
```

### Database

```{r}
cards <- c(rep("Bear", 12), 
           rep("Bee", 8), 
           rep("Meadow", 20),
           rep("Trout", 10),
           rep("Eagle", 8),
           rep("Rabbit", 8),
           rep("Dragonfly", 8),
           rep("Fox", 12),
           rep("Deer", 12),
           rep("Stream", 20),
           rep("Wolf", 12)
           )

dfly_stream <- c(rep("Bear", 6), 
           rep("Bee", 4), 
           rep("Meadow", 10),
           rep("Trout", 5),
           rep("Eagle", 4),
           rep("Rabbit", 4),
           rep("Dragonfly", 8),
           rep("Fox", 6),
           rep("Deer", 6),
           rep("Stream", 20),
           rep("Wolf", 6)
           )

bee_meadow <- c(rep("Bear", 6), 
           rep("Bee", 8), 
           rep("Meadow", 20),
           rep("Trout", 5),
           rep("Eagle", 4),
           rep("Rabbit", 4),
           rep("Dragonfly", 4),
           rep("Fox", 6),
           rep("Deer", 6),
           rep("Stream", 10),
           rep("Wolf", 6)
           )

low_eag_rab <- c(rep("Bear", 12), 
           rep("Bee", 8), 
           rep("Meadow", 20),
           rep("Trout", 10),
           rep("Eagle", 2),
           rep("Rabbit", 2),
           rep("Dragonfly", 8),
           rep("Fox", 12),
           rep("Deer", 12),
           rep("Stream", 20),
           rep("Wolf", 12)
           )
```

```{r, eval=FALSE}
startTime <- Sys.time()

db_gen <- multi_mcmc(1000, 2000, "annealing dynamic", 0.9, 200, record_board = TRUE, cards = low_eag_rab, card_name = "low_eagle_rabbit")
endTime <- Sys.time()
print(endTime - startTime)

database_old <- read.csv(here::here("database.csv"))
database_new <- rbind(database_old, db_gen)
database_new <- database_new %>% distinct()
write.csv(database_new, here::here("database.csv"), row.names = FALSE)
```

```{r, eval=FALSE}
head(db_gen)
```
```{r}
database_new <- database_new %>% mutate(score = as.numeric(score))
```

```{r, eval=FALSE}
# write.csv(db_gen, here::here("database.csv"), row.names = FALSE)
```

```{r, eval=FALSE}
database_old <- read.csv(here::here("database.csv"))
```

```{r, eval=FALSE}
database_new <- rbind(database_old, db_gen)
write.csv(database_new, here::here("database.csv"), row.names = FALSE)
```

```{r, eval=FALSE}
database_new <- database_new %>% distinct()
```

```{r}
database_new <- read.csv(here::here("database.csv"))
```


```{r}
database_new %>%
  mutate(score = as.numeric(score)) %>%
  filter(pool == "default") %>%
  ggplot(aes(x = score)) +
  geom_histogram(binwidth = 3, fill = "steelblue", color = "black")
```

```{r}
database_new %>%
  mutate(score = as.numeric(score)) %>%
  filter(pool == "dragonfly_stream") %>%
  ggplot(aes(x = score)) +
  geom_histogram(binwidth = 3, fill = "steelblue", color = "black")
```
```{r}
database_new %>%
  mutate(score = as.numeric(score)) %>%
  filter(pool == "bee_meadow") %>%
  ggplot(aes(x = score)) +
  geom_histogram(binwidth = 3, fill = "steelblue", color = "black")
```


```{r}
database_new %>%
  mutate(score = as.numeric(score)) %>%
  filter(pool == "low_eagle_rabbit") %>%
  ggplot(aes(x = score)) +
  geom_histogram(binwidth = 3, fill = "steelblue", color = "black")
```
### Clustering

```{r}
database_new <- read.csv(here::here("database.csv"))
```

```{r}
grids <- database_new %>% select(-c(pool))

dmy <- dummyVars(" ~ .", data = grids)

grids <- data.frame(predict(dmy, newdata = grids))

grids_matrix <- as.matrix(grids)

```


```{r}
km_spec1 <- k_means(num_clusters = 4)

grids_recipe <- recipe(~., data = grids_matrix)

km_wflow1 <- workflow() |>
  add_recipe(grids_recipe) |>
  add_model(km_spec1)

km_fitted1 <- km_wflow1 |> fit(grids_matrix)

km_fitted1 |> extract_centroids()

grids_km1 <- kmeans(grids_matrix, centers = 4)

grids_km1$totss
grids_km1$withinss
grids_km1$betweenss
```

```{r}
x <- km_fitted1 |> extract_centroids()
x
```

```{r}
pc <- prcomp(grids_matrix)
```

```{r}
cumul_vars <- cumsum(pc$sdev^2)/sum(pc$sdev^2)
cumul_vars
```

```{r}
grids_reduced <- pc$x[, 1:8]

grids_pca_km <- kmeans(grids_reduced, 4)

grids_pca_km$totss
grids_pca_km$withinss
grids_pca_km$betweenss
```
```{r}
pc$rotation[,1:2]
```


### Testings

```{r}
two_player <- list(c(37,4,2,2), c(45,3,3,3))
four_player <- list(c(37,5,1,2), c(45,2,4,3), c(60,0,0,0), c(47,4,3,4))
five_player <- list(c(37,3,0,2), c(45,2,4,3), c(60,3,0,0), c(47,2,0,4), c(38,1,4,4))
```

```{r}
mp_score(two_player)
```

```{r}
mp_score(four_player)
```

```{r}
mp_score(five_player)
```

```{r}
z <- score_grid(sample_grid)
z
```

```{r}
z2 <- score_grid(sample_grid2)
z2
```

```{r}
z3 <- score_grid(big_grid1)
z3
```

```{r}
set.seed(48)
test_grid <- generate_grid(cards)
test_grid
x <- find_cardinals(0,3,test_grid)
x
c <- sample(x, 1)
c
"el"
c[[1]][1]
score_grid(test_grid)
```

```{r}
solo_score(score_grid(test_grid))
```

```{r}
set.seed(48)
baseline_scores <- baseline_sim(cards)
```

```{r}
mean(baseline_scores)
sd(baseline_scores)
var(baseline_scores)
max(baseline_scores)
min(baseline_scores)
summary(baseline_scores)
```

```{r}
baseline_data <- data.frame(baseline_scores)
ggplot(aes(x = baseline_scores), data = baseline_data) +
  geom_histogram(binwidth = 5, fill = "steelblue")
```

